/* Automatically generated by Ragel from "src/claro/graphics/layout/layout_parser.rl".
 *
 * Parts of this file are copied from Ragel source covered by the GNU
 * GPL. As a special exception, you may use the parts of this file copied
 * from Ragel source without restriction. The remainder is derived from
 * "src/claro/graphics/layout/layout_parser.rl" and inherits the copyright status of that file.
 */

#line 1 "src/claro/graphics/layout/layout_parser.rl"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <claro/graphics.h>
#include "layout_heap.h"

#define CELL_AT(I) (lt->heap->index[(I)])

inline void start_cell(layout_t *lt, int isrow) 
{
    cell_t *cl = NULL;
    
    cl = calloc(1, sizeof(cell_t));
    assert(cl);
    cl->bounds.owner = (object_t *)lt;
    
    if(isrow) {
        cl->flags.row = 1;
        // this will set the row start to the cell we're about to add
        lt->row.start = layout_heap_size(lt->heap);
        lt->row.total++;
    } 
    
    layout_heap_push(lt->heap, cl);
}


/**
 * During cell processing each cell has modifies applied to it that change layout_t.col 
 * parameters.  This then goes back through and sets the final widths for each cell.
 *
 * The parameters that are maintained during the row building are:
 * 
 * col.fixed_w -- the total width of all fixed elements.
 * col.fixed_count -- the NUMBER of flixed columns.  These are set during this function.
 * col.min -- the min is the default minimum for the fixed width cells.
 */

inline void end_row(layout_t *lt)
{
    cell_t *start = NULL;
    cell_t *cl = NULL;
    cell_t *prev = NULL;
    int i = 0;
    int flex_size = 0;
    int flex_count = 0;
    
    // we must calculate the difference in fixed vs. variable width, then divide the remaining
    // width amongst the number of variable width elements.  By default cells in a row are flex (variable).
    start = CELL_AT(lt->row.start);
    
    // this gets the number of columns
    start->ncols = layout_heap_size(lt->heap) - lt->row.start;
    assert(start->ncols > 0 && "number of columns not calculated right");

    // we now have the number of cells, the number that are flexed, the min, and finally the amount of fixed_w
    flex_count = start->ncols - lt->col.fixed_count;
    assert(flex_count >= 0 && "number of flex counts below 0.  not possible");
    
    // we only need to set the flex columns if there are some
    if(flex_count > 0) {
        flex_size = (lt->bounds.w - lt->col.fixed_w) / flex_count;
    }
    
    for(i = lt->row.start; i < layout_heap_size(lt->heap); i++) {
        cl = lt->heap->ordered[i];
        if(!cl->flags.set_w && !cl->flags.fixed_w) {
            cl->bounds.w = flex_size;
        } 
        
        // all cells get their x values adjusted
        if(prev) {
            cl->bounds.x = prev->bounds.x + prev->bounds.w;
        }
        
        prev = cl;
    }

    
    // clear row start for the next row
    lt->col.fixed_w=0;
    lt->col.fixed_count=0;
    lt->row.start=0;
}

inline void update_name(layout_t *lt, char fc)
{
    cell_t *cl = layout_heap_top(lt->heap);

    int len = strlen(cl->name);
    assert(len < 31 && "Layout name is too long");
    cl->name[len] = fc;
    cl->name[len+1] = '\0';
}

inline void flex_row(layout_t *lt) 
{
    cell_t *cl = layout_heap_top(lt->heap);
    cl->flags.flex_h = 1;
    lt->row.flex_count++;
}


/**
 * Sets this cell to have the min width, sets it to be flags.fixed_w, and adds to the layout_t.col.fixed_w total
 * for the end_row function.
 */
inline void fixed_width(layout_t *lt) 
{
    cell_t *cl = layout_heap_top(lt->heap);
    assert(!cl->flags.set_w && "You already set this cell with a specific width.  Don't do col(20)<");
    cl->bounds.w = lt->col.min;
    cl->flags.fixed_w = 1;

    lt->col.fixed_w += lt->col.min;
    lt->col.fixed_count++;
}


/**
 * Sets this cell to have a specific width [specified as mystuff(40)] and adjusts the
 * total layout_t.col.fixed_w to include this width.
 */
inline void set_width(layout_t *lt) 
{
    cell_t *cl = layout_heap_top(lt->heap);
    assert(!cl->flags.fixed_w && "You already set this cell to fixed width.  Don't do >col(10)");
    cl->bounds.w = strtol(lt->temp+1, NULL, 10);
    cl->flags.set_w = 1;

    lt->col.fixed_w += cl->bounds.w;
    lt->col.fixed_count++;
}


/**
 * Sets this cell to have a specific width [specified as mystuff(40)] and adjusts the
 * total layout_t.col.fixed_w to include this width.
 */
inline void set_height(layout_t *lt) 
{
    cell_t *cl = layout_heap_top(lt->heap);
    assert(!cl->flags.fixed_w && "You already set this cell to fixed width.  Don't do >col(10)");
    cl->bounds.h = strtol(lt->temp+1, NULL, 10);
    cl->flags.set_h = 1;

    lt->row.set_h += cl->bounds.h;
    lt->row.set_count++;
}


// goes back through the whole list of cells and sets the vertical coords based on flex settings
inline void finish_layout(layout_t *lt) 
{
    cell_t **cl = NULL;
    size_t i = 0;
    size_t size = 0;
    
    int fixed_rows = 0;
    int flex_size = 0;
    int flex_avail = 0;
    int cur_y = 0;
    int cur_h = 0;
    

    fixed_rows = lt->row.total - lt->row.flex_count - lt->row.set_count;
    flex_avail = lt->bounds.h - (fixed_rows * lt->row.min + lt->row.set_h);
    if(lt->row.flex_count) {
        flex_size = flex_avail / lt->row.flex_count;
    }
    
    cur_y = 0;
    cur_h = 0;
        
    for(i = 0, cl = layout_in_order(lt, &size); i < size; i++) {
        if(cl[i]->flags.row){
            cur_y += cur_h;  // move down from last y

            if(cl[i]->flags.flex_h) {
                cur_h = flex_size;  // adopt a flex height
            } else if(cl[i]->flags.set_h) {
                cur_h = cl[i]->bounds.h;  // this has a set height, leave it alone
            } else {
                // adopt a fixed minimum height
                cur_h = lt->row.min;
            }
        }
        
        cl[i]->bounds.h = cur_h;
        cl[i]->bounds.y = cur_y;
    }

#ifdef LOG_DEBUG
    layout_dump(lt);
#endif
    
    if(!lt->heap->sorted) {
        layout_heap_sort(lt->heap);  // this sorts the heap so cells can be found by name
    }
}


void layout_reparse(layout_t *lt, bounds_t bounds, int min_w, int min_h)
{
    size_t i = 0;
    size_t size = 0;
    cell_t **cl = NULL;
    int top = 0;
    int orig_top = 0;
    
    assert(lt != NULL && "layout was NULL");
    assert(min_w >= 0 && "min_w must be >= 0");
    assert(min_h >= 0 && "min_h must be >= 0");
    
    
    lt->row.min = min_h;
    lt->col.min = min_w;
    lt->bounds = bounds;
    lt->col.fixed_w=0;
    lt->col.fixed_count=0;
    lt->row.start=0;
    
    
    // we skip the very first cell since it's always a row
    lt->row.start = 0;  // the first row
    orig_top = lt->heap->top;
    for(i = 0, cl = layout_in_order(lt, &size); i < size; i++) {
        top = lt->heap->top;

        if(cl[i]->flags.row && i != 0) {
            lt->heap->top = i;  // go back real quick to simulate end of row ]
            end_row(lt);
            lt->row.start = i;
        }

        // fixed width setting must be after processing end row otherwise end_row will reset
        // the fixed with column count
        if(cl[i]->flags.fixed_w) {
            cl[i]->bounds.w = lt->col.min;
            lt->col.fixed_w += lt->col.min;
            lt->col.fixed_count++;
        }
        
        if(cl[i]->flags.set_w) {
            lt->col.fixed_w += cl[i]->bounds.w;
            lt->col.fixed_count++;
        }
        
        lt->heap->top = top;
    }
    
    end_row(lt);
    finish_layout(lt);
    // done now finish the layout
    assert(lt->heap->top == orig_top && "after reparse the heap is not the right size");
}



#line 271 "src/claro/graphics/layout/layout_parser.c"
static int layout__start = 0;

int layout__init( struct layout_ *fsm )
{
	fsm->curs = layout__start;
	return 0;
}

int layout__execute( struct layout_ *fsm, const char *_data, int _len )
{
	const char *_p = _data-1;
	const char *_pe = _data+_len;
	int _cs = fsm->curs;
	fsm->curs = -1;

	if ( ++_p == _pe )
		goto out;
	switch ( _cs ) {
case 0:
	if ( (*_p) == 91 )
		goto tr2;
	goto st1;
st1:
	if ( ++_p == _pe )
		goto out1;
case 1:
	goto st1;
tr2:
#line 266 "src/claro/graphics/layout/layout_parser.rl"
	{ start_cell(fsm, 1);  }
	goto st2;
st2:
	if ( ++_p == _pe )
		goto out2;
case 2:
#line 307 "src/claro/graphics/layout/layout_parser.c"
	switch( (*_p) ) {
		case 32: goto st3;
		case 40: goto tr8;
		case 46: goto tr9;
		case 60: goto tr10;
		case 62: goto tr10;
		case 93: goto tr11;
		case 95: goto tr13;
		case 123: goto tr14;
		case 124: goto st7;
	}
	if ( (*_p) < 48 ) {
		if ( 9 <= (*_p) && (*_p) <= 13 )
			goto st3;
	} else if ( (*_p) > 57 ) {
		if ( (*_p) > 90 ) {
			if ( 97 <= (*_p) && (*_p) <= 122 )
				goto tr9;
		} else if ( (*_p) >= 65 )
			goto tr9;
	} else
		goto tr9;
	goto st1;
tr21:
#line 272 "src/claro/graphics/layout/layout_parser.rl"
	{ set_width(fsm); }
	goto st3;
tr17:
#line 265 "src/claro/graphics/layout/layout_parser.rl"
	{ start_cell(fsm, 0); }
#line 268 "src/claro/graphics/layout/layout_parser.rl"
	{ update_name(fsm, (*_p)); }
	goto st3;
tr18:
#line 265 "src/claro/graphics/layout/layout_parser.rl"
	{ start_cell(fsm, 0); }
#line 271 "src/claro/graphics/layout/layout_parser.rl"
	{ fixed_width(fsm); }
	goto st3;
tr23:
#line 272 "src/claro/graphics/layout/layout_parser.rl"
	{ set_width(fsm); }
#line 268 "src/claro/graphics/layout/layout_parser.rl"
	{ update_name(fsm, (*_p)); }
	goto st3;
tr24:
#line 272 "src/claro/graphics/layout/layout_parser.rl"
	{ set_width(fsm); }
#line 271 "src/claro/graphics/layout/layout_parser.rl"
	{ fixed_width(fsm); }
	goto st3;
tr9:
#line 268 "src/claro/graphics/layout/layout_parser.rl"
	{ update_name(fsm, (*_p)); }
	goto st3;
tr10:
#line 271 "src/claro/graphics/layout/layout_parser.rl"
	{ fixed_width(fsm); }
	goto st3;
tr27:
#line 273 "src/claro/graphics/layout/layout_parser.rl"
	{ set_height(fsm); }
	goto st3;
tr30:
#line 273 "src/claro/graphics/layout/layout_parser.rl"
	{ set_height(fsm); }
#line 271 "src/claro/graphics/layout/layout_parser.rl"
	{ fixed_width(fsm); }
	goto st3;
tr29:
#line 273 "src/claro/graphics/layout/layout_parser.rl"
	{ set_height(fsm); }
#line 268 "src/claro/graphics/layout/layout_parser.rl"
	{ update_name(fsm, (*_p)); }
	goto st3;
tr13:
#line 267 "src/claro/graphics/layout/layout_parser.rl"
	{ flex_row(fsm); }
	goto st3;
tr15:
#line 265 "src/claro/graphics/layout/layout_parser.rl"
	{ start_cell(fsm, 0); }
	goto st3;
st3:
	if ( ++_p == _pe )
		goto out3;
case 3:
#line 395 "src/claro/graphics/layout/layout_parser.c"
	switch( (*_p) ) {
		case 32: goto st3;
		case 40: goto tr8;
		case 46: goto tr9;
		case 60: goto tr10;
		case 62: goto tr10;
		case 93: goto tr11;
		case 124: goto st7;
	}
	if ( (*_p) < 48 ) {
		if ( 9 <= (*_p) && (*_p) <= 13 )
			goto st3;
	} else if ( (*_p) > 57 ) {
		if ( (*_p) > 90 ) {
			if ( 97 <= (*_p) && (*_p) <= 122 )
				goto tr9;
		} else if ( (*_p) >= 65 )
			goto tr9;
	} else
		goto tr9;
	goto st1;
tr16:
#line 265 "src/claro/graphics/layout/layout_parser.rl"
	{ start_cell(fsm, 0); }
#line 281 "src/claro/graphics/layout/layout_parser.rl"
	{ fsm->temp = _p; }
	goto st4;
tr22:
#line 272 "src/claro/graphics/layout/layout_parser.rl"
	{ set_width(fsm); }
#line 281 "src/claro/graphics/layout/layout_parser.rl"
	{ fsm->temp = _p; }
	goto st4;
tr8:
#line 281 "src/claro/graphics/layout/layout_parser.rl"
	{ fsm->temp = _p; }
	goto st4;
tr28:
#line 273 "src/claro/graphics/layout/layout_parser.rl"
	{ set_height(fsm); }
#line 281 "src/claro/graphics/layout/layout_parser.rl"
	{ fsm->temp = _p; }
	goto st4;
st4:
	if ( ++_p == _pe )
		goto out4;
case 4:
#line 443 "src/claro/graphics/layout/layout_parser.c"
	if ( 48 <= (*_p) && (*_p) <= 57 )
		goto st5;
	goto st1;
st5:
	if ( ++_p == _pe )
		goto out5;
case 5:
	if ( (*_p) == 41 )
		goto st6;
	if ( 48 <= (*_p) && (*_p) <= 57 )
		goto st5;
	goto st1;
st6:
	if ( ++_p == _pe )
		goto out6;
case 6:
	switch( (*_p) ) {
		case 32: goto tr21;
		case 40: goto tr22;
		case 46: goto tr23;
		case 60: goto tr24;
		case 62: goto tr24;
		case 93: goto tr25;
		case 124: goto tr26;
	}
	if ( (*_p) < 48 ) {
		if ( 9 <= (*_p) && (*_p) <= 13 )
			goto tr21;
	} else if ( (*_p) > 57 ) {
		if ( (*_p) > 90 ) {
			if ( 97 <= (*_p) && (*_p) <= 122 )
				goto tr23;
		} else if ( (*_p) >= 65 )
			goto tr23;
	} else
		goto tr23;
	goto st1;
tr25:
#line 272 "src/claro/graphics/layout/layout_parser.rl"
	{ set_width(fsm); }
#line 269 "src/claro/graphics/layout/layout_parser.rl"
	{ end_row(fsm); }
	goto st11;
tr31:
#line 273 "src/claro/graphics/layout/layout_parser.rl"
	{ set_height(fsm); }
#line 269 "src/claro/graphics/layout/layout_parser.rl"
	{ end_row(fsm); }
	goto st11;
tr11:
#line 269 "src/claro/graphics/layout/layout_parser.rl"
	{ end_row(fsm); }
	goto st11;
tr19:
#line 265 "src/claro/graphics/layout/layout_parser.rl"
	{ start_cell(fsm, 0); }
#line 269 "src/claro/graphics/layout/layout_parser.rl"
	{ end_row(fsm); }
	goto st11;
st11:
	if ( ++_p == _pe )
		goto out11;
case 11:
#line 507 "src/claro/graphics/layout/layout_parser.c"
	switch( (*_p) ) {
		case 32: goto st11;
		case 91: goto tr2;
	}
	if ( 9 <= (*_p) && (*_p) <= 13 )
		goto st11;
	goto st1;
tr26:
#line 272 "src/claro/graphics/layout/layout_parser.rl"
	{ set_width(fsm); }
	goto st7;
tr32:
#line 273 "src/claro/graphics/layout/layout_parser.rl"
	{ set_height(fsm); }
	goto st7;
tr20:
#line 265 "src/claro/graphics/layout/layout_parser.rl"
	{ start_cell(fsm, 0); }
	goto st7;
st7:
	if ( ++_p == _pe )
		goto out7;
case 7:
#line 531 "src/claro/graphics/layout/layout_parser.c"
	switch( (*_p) ) {
		case 32: goto tr15;
		case 40: goto tr16;
		case 46: goto tr17;
		case 60: goto tr18;
		case 62: goto tr18;
		case 93: goto tr19;
		case 124: goto tr20;
	}
	if ( (*_p) < 48 ) {
		if ( 9 <= (*_p) && (*_p) <= 13 )
			goto tr15;
	} else if ( (*_p) > 57 ) {
		if ( (*_p) > 90 ) {
			if ( 97 <= (*_p) && (*_p) <= 122 )
				goto tr17;
		} else if ( (*_p) >= 65 )
			goto tr17;
	} else
		goto tr17;
	goto st1;
tr14:
#line 282 "src/claro/graphics/layout/layout_parser.rl"
	{ fsm->temp = _p; }
	goto st8;
st8:
	if ( ++_p == _pe )
		goto out8;
case 8:
#line 561 "src/claro/graphics/layout/layout_parser.c"
	if ( 48 <= (*_p) && (*_p) <= 57 )
		goto st9;
	goto st1;
st9:
	if ( ++_p == _pe )
		goto out9;
case 9:
	if ( (*_p) == 125 )
		goto st10;
	if ( 48 <= (*_p) && (*_p) <= 57 )
		goto st9;
	goto st1;
st10:
	if ( ++_p == _pe )
		goto out10;
case 10:
	switch( (*_p) ) {
		case 32: goto tr27;
		case 40: goto tr28;
		case 46: goto tr29;
		case 60: goto tr30;
		case 62: goto tr30;
		case 93: goto tr31;
		case 124: goto tr32;
	}
	if ( (*_p) < 48 ) {
		if ( 9 <= (*_p) && (*_p) <= 13 )
			goto tr27;
	} else if ( (*_p) > 57 ) {
		if ( (*_p) > 90 ) {
			if ( 97 <= (*_p) && (*_p) <= 122 )
				goto tr29;
		} else if ( (*_p) >= 65 )
			goto tr29;
	} else
		goto tr29;
	goto st1;
	}
	out1: _cs = 1; goto out;
	out2: _cs = 2; goto out;
	out3: _cs = 3; goto out;
	out4: _cs = 4; goto out;
	out5: _cs = 5; goto out;
	out6: _cs = 6; goto out;
	out11: _cs = 11; goto out;
	out7: _cs = 7; goto out;
	out8: _cs = 8; goto out;
	out9: _cs = 9; goto out;
	out10: _cs = 10; goto out;

out:
	fsm->curs = _cs;
	if ( _cs == 1 )
		return -1;
	if ( _cs >= 11 )
		return 1;
	return 0;
}

int layout__finish( struct layout_ *fsm )
{
	int _cs = fsm->curs;
	fsm->curs = -1;
	switch ( _cs ) {
	case 11: 
#line 270 "src/claro/graphics/layout/layout_parser.rl"
	{ finish_layout(fsm); }
	break;
#line 630 "src/claro/graphics/layout/layout_parser.c"
	}

	fsm->curs = _cs;
	if ( fsm->curs == 1 )
		return -1;
	if ( fsm->curs >= 11 )
		return 1;
	return 0;
}

#line 286 "src/claro/graphics/layout/layout_parser.rl"

